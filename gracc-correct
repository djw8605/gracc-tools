#!/usr/bin/env python

import argparse
import sys
import json

from elasticsearch import Elasticsearch


class Correction(object):
    def __init__(self, ctype, key, correction, other_keys=[]):
        self.ctype = ctype
        self.key = key
        self.other_keys = other_keys
        self.correction = correction

    def keys(self):
        return [self.key]+self.other_keys+[self.correction]

    def create(self, es, index, doc):
        """
        Create correction in the given index in Elasticsearch client es.
        :param dict doc: a dictionary containing the correction fields (keys and correction)
        :return bool: success or failure
        """
        for k in self.keys():
            if k not in doc.keys():
                print 'Error: missing key %s'%k
                return False
        if len(self.get(es,index,doc)) > 0:
            print 'Error: correction exists'
            return False
        ## create doc
        r = es.index(index=index, doc_type=self.ctype, body=doc)
        if r['_shards']['successful'] < 1:
            print 'Error creating correction. Response:'
            print r
            return False
        else:
            print 'Correction created. id: %s' % r['_id']
        return True

    def update(self, es, index, doc):
        """
        Update correction in the given index in Elasticsearch client es.
        :param dict doc: a dictionary containing the correction fields (keys and correction)
        :return bool: success or failure
        """
        for k in self.keys():
            if k not in doc.keys():
                print 'Error: missing key %s'%k
                return False
        docs = self.get(es,index,doc)
        if len(docs) == 0:
            print 'Error: correction doesn\'t exist'
            return False
        for d in docs:
            r = es.update(index=index, doc_type=self.ctype, id=d['_id'], body={'doc':doc})
            if r['result'] not in ['updated','noop']:
                print 'Error updating correction. Response:'
                print r
                return False
            else:
                print 'Correction %s updated.' % d['_id']
        return True

    def destroy(self, es, index, doc):
        """
        Delete correction in the given index in Elasticsearch client es.
        :param dict doc: a dictionary containing the correction fields (keys and correction)
        :return bool: success or failure
        """
        for k in self.keys():
            if k not in doc.keys():
                print 'Error: missing key %s'%k
                return False
        docs = self.get(es,index,doc)
        if len(docs) == 0:
            print 'Error: correction doesn\'t exist'
            return False
        for d in docs:
            r = es.delete(index=index, doc_type=self.ctype, id=d['_id'])
            if r['_shards']['successful'] < 1:
                print 'Error deleting correction. Response:'
                print r
                return False
            else:
                print 'Correction %s deleted.' % r['_id']
        return True

    def get(self, es, index, doc={}, size=100):
        """
        Fetch correction from the given index in Elasticsearch client es.
        :param dict doc: a dictionary containing the fields to be matched. The corrected field is dropped.
        :return list: documents (empty if no matches or error)
        """
        if len(doc.keys()) > 0:
            for k in doc.keys():
                if k not in self.keys():
                    print 'Error: invalid key %s for correction %s' % (k, self.ctype)
            q = ' AND '.join([k+':'+v for k, v in doc.iteritems() if k != self.correction])
        else:
            q = '*'
        r = es.search(index=index, doc_type=self.ctype, q=q, size=size)
        try:
            return r['hits']['hits']
        except:
            return []

    def prompt(self):
        """
        Prompt user for correction fields.
        :return dict: fields
        """
        doc={}
        print('Field(s) to correct:')
        for k in [self.key]+self.other_keys:
            doc[k] = raw_input('    %s: '%k)
        doc[self.correction] = raw_input('Corrected %s: '%self.key)
        return doc


corrections = {
    'vo': Correction(ctype='vo',
                     key='VOName',
                     other_keys=['ReportableVOName'],
                     correction='CorrectedVOName'),
    'project': Correction(ctype='project',
                          key='ProjectName',
                          correction='CorrectedProjectName')
}

def main():
    parser = argparse.ArgumentParser('Manage GRACC corrections.')
    parser.add_argument('command', choices=['list','add','update','delete'],
                        help='Command to perform')
    parser.add_argument('type', choices=corrections.keys(),
                        help='Correction type')
    parser.add_argument('doc', nargs='?', default=None,
                        help='Option JSON document with correction source.')
    parser.add_argument('--url', type=str, default='http://localhost:9200',
                        help='Elasticsearch URL')
    parser.add_argument('--index', type=str, default='gracc.corrections-0',
                        help='Index containing corrections')
    parser.add_argument('--size', type=int, default=1000,
                        help='Max number of documents to list.')
    args = parser.parse_args()

    es = Elasticsearch(args.url)
    correction = corrections[args.type]

    if args.command == 'list':
        if args.doc is not None:
            doc = json.loads(args.doc)
        else:
            doc = {}
        docs = correction.get(es,args.index,doc,size=args.size)
        print '\t'.join(['id']+correction.keys())
        for d in docs:
            print '\t'.join([d['_id']]+['%s'%d['_source'][k] for k in correction.keys()])
    elif args.command == 'add':
        if args.doc is not None:
            doc = json.loads(args.doc)
        else:
            doc = correction.prompt()
        if not correction.create(es,args.index,doc):
            if raw_input('Create failed. Attempt update instead? (Y/N) ').upper() == 'Y':
                correction.update(es,args.index,doc)
    elif args.command == 'update':
        if args.doc is not None:
            doc = json.loads(args.doc)
        else:
            doc = correction.prompt()
        if not correction.update(es,args.index,doc):
            if raw_input('Update failed. Attempt create instead? (Y/N) ').upper() == 'Y':
                correction.create(es,args.index,doc)
    elif args.command == 'delete':
        if args.doc is not None:
            doc = json.loads(args.doc)
        else:
            doc = correction.prompt()
        correction.destroy(es,args.index,doc)
    else:
        print '%s not implemented'%args.command
        sys.exit(1)


if __name__=="__main__":
    main()
